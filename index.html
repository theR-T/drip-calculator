<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DRIP Returns Calculator</title>
  <link rel="stylesheet" href="styles-front.css"/>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <section id="drip-calculator">
    <h2>DRIP Returns Calculator</h2>

    <label for="initialInvestment">Initial Investment ($)</label>
    <input id="initialInvestment" type="number" min="0" step="100" value="50000"/>

    <label for="annualRate">Annual Dividend Yield (%)</label>
    <input id="annualRate" type="number" min="0" step="0.01" value="9.75"/>

    <label for="years">Time Horizon (years)</label>
    <input id="years" type="number" min="1" step="1" value="20"/>

    <label for="contributionAmount">Additional Contribution Amount ($)</label>
    <input id="contributionAmount" type="number" min="0" step="100" value="0"/>

    <label for="contributionFrequency">Contribution Frequency (months)</label>
    <input id="contributionFrequency" type="number" min="1" step="1" value="12"/>

    <button id="calculateDrip">Calculate</button>

    <div id="dripResults" aria-live="polite"></div>
    <canvas id="dripChart"></canvas>
    <div id="dripTableContainer"></div>
    <div id="dripActions">
      <button id="downloadCsv">Export CSV</button>
      <button id="downloadChart">Download Chart</button>
      <button id="emailData">Email Data</button>
    </div>
  </section>

  <script>
    // 1) pre-load your background image
    const bgImage = new Image();
    bgImage.src   = 'assets/MorrisonM.png';   // adjust path as needed

    // 2) define a tiny plugin to paint it before the chart draws
    const bgPlugin = {
      id: 'bgImage',
      beforeDraw: chart => {
        const { ctx, chartArea, width: cw, height: ch } = chart;
        if (!bgImage.complete) return;

        // how big you want it relative to chart area
        const SCALE = 0.5;
        const imgRatio = bgImage.width / bgImage.height;

        // scale image to SCALE× chartArea width
        const dw = chartArea.width * SCALE;
        const dh = dw / imgRatio;

        // center it inside the chartArea
        const dx = chartArea.left + (chartArea.width - dw) / 2;
        const dy = chartArea.top  + (chartArea.height - dh) / 2;

        ctx.save();
        ctx.globalAlpha = 0.;
        ctx.drawImage(bgImage, dx, dy, dw, dh);
        ctx.restore();
      }
    };

    // 3) register it globally
    Chart.register(bgPlugin);

    let dripChart, dripData;

    document.getElementById('calculateDrip').addEventListener('click', () => {
      const P     = parseFloat(document.getElementById('initialInvestment').value);
      const r     = parseFloat(document.getElementById('annualRate').value) / 100;
      const yrs   = parseInt(document.getElementById('years').value, 10);
      const C     = parseFloat(document.getElementById('contributionAmount').value);
      const freq  = parseInt(document.getElementById('contributionFrequency').value, 10);
      if ([P, r, yrs, C, freq].some(v => isNaN(v) || v < 0) || yrs===0||freq===0) {
        return alert('Enter valid non-negative numbers and years/frequency ≥1');
      }

      const months           = yrs * 12;
      const monthlyRate      = r / 12;
      let principalDrip      = P;
      let principalNonDrip   = P;
      let accNonDripInterest = 0;
      let contribTotal       = 0;

      // track cumulative sums
      let cumulativeDividendGain    = 0;
      let cumulativeNonDripDividend = 0;

      const avgAnnualDripArr        = [];
      const totalDripReturnArr      = [];
      const totalNonDripReturnArr   = [];
      const labels                  = [];
      const regReturnArr            = [];
      const dripReturnArr           = [];
      const contribThisMonthArr     = [];
      const cashflows               = [];

      cashflows.push(-P);

      for (let m = 1; m <= months; m++) {
        // DRIP side
        const iDrip = principalDrip * monthlyRate;
        principalDrip += iDrip;
        cumulativeDividendGain += iDrip;

        // non-DRIP side
        const iNon = principalNonDrip * monthlyRate;
        accNonDripInterest += iNon;
        cumulativeNonDripDividend += iNon;

        // contributions
        let added = 0;
        if (C > 0 && m % freq === 0) {
          principalDrip    += C;
          principalNonDrip += C;
          contribTotal     += C;
          added = C;
        }
        contribThisMonthArr.push(added);
        cashflows.push(-added);

        // record raw returns
        regReturnArr.push(iNon);
        dripReturnArr.push(iDrip);

        // record totals
        totalNonDripReturnArr.push(cumulativeNonDripDividend);
        totalDripReturnArr.push(cumulativeDividendGain);

        // labels
        labels.push(m);
      }

      // finalize final cashflow
      cashflows[cashflows.length - 1] += principalDrip;

      // compute annualized IRR
      function irr(cfs, guess=0.01) {
        let rate = guess;
        for (let iter=0; iter<50; iter++) {
          let f=0, fprime=0;
          cfs.forEach((cf,k) => {
            f      += cf/Math.pow(1+rate,k);
            fprime += -k*cf/Math.pow(1+rate,k+1);
          });
          const newRate = rate - f/fprime;
          if (Math.abs(newRate-rate) < 1e-9) break;
          rate = newRate;
        }
        return rate;
      }
      const monthlyIRR     = irr(cashflows);
      const annualizedDrip = Math.pow(1+monthlyIRR, 12) - 1;

      dripData = {
        labels,
        regReturnArr,
        dripReturnArr,
        totalNonDripReturnArr,
        totalDripReturnArr,
        contribThisMonthArr,
        annualizedDrip
      };

      // Results summary
      const fmt = n=>n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
      document.getElementById('dripResults').innerHTML = `
        <div class="result-row">
          <strong>Annualized DRIP Return:</strong>
          <span>${(annualizedDrip*100).toFixed(2)}%</span>
        </div>`;

      // Detail table
      const rows = labels.map((m,i) => {
        let principalCell = '<td></td>';
        if (i===0) principalCell = `<td>$${fmt(P)}</td>`;
        else if (contribThisMonthArr[i]>0) principalCell = `<td>$${fmt(contribThisMonthArr[i])}</td>`;
        return `
          <tr>
            <td>${m}</td>
            ${principalCell}
            <td>$${fmt(regReturnArr[i])}</td>
            <td>$${fmt(dripReturnArr[i])}</td>
            <td>$${fmt(totalNonDripReturnArr[i])}</td>
            <td>$${fmt(totalDripReturnArr[i])}</td>
          </tr>`;
      }).join('');

      document.getElementById('dripTableContainer').innerHTML = `
        <table class="drip-detail-table">
          <thead>
            <tr>
              <th>Month</th>
              <th>Principal Invested</th>
              <th>Regular Return</th>
              <th>DRIP Return</th>
              <th>Total non-DRIP Return</th>
              <th>Total DRIP Return</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>`;

      // Build yearly arrays (every 12 months)
      const yearLabels     = [];
      const yearlyDrip     = [];
      const yearlyNonDrip  = [];
      labels.forEach((m, i) => {
        if (m % 12 === 0) {
          yearLabels.push(m / 12);
          yearlyDrip.push(totalDripReturnArr[i]);
          yearlyNonDrip.push(totalNonDripReturnArr[i]);
        }
      });

      // Draw chart
      if (dripChart) dripChart.destroy();
      Chart.defaults.font.family = getComputedStyle(document.body).fontFamily;
      Chart.defaults.color       = getComputedStyle(document.body).color;
      const ctx = document.getElementById('dripChart').getContext('2d');
      Chart.defaults.devicePixelRatio = 2;
      dripChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: yearLabels,
          datasets: [
            {
              label: 'With DRIP',
              data:  yearlyDrip,
              borderColor:          '#006644',
              pointBackgroundColor: '#006644',
              pointBorderColor:     '#ffffff',  // white ring around the point
              pointRadius:          4,
              tension:              0.3,
              fill:                 false
            },
            {
              label: 'Without DRIP',
              data:  yearlyNonDrip,
              borderColor:          '#004C84',
              pointBackgroundColor: '#004C84',
              pointBorderColor:     '#ffffff',
              pointRadius:          4,
              tension:              0.3,
              fill:                 false
            }
          ]
        },
        options: {
          responsive:true, maintainAspectRatio:true, aspectRatio:2,
          scales: {
            x: {
              type: 'category',       // treat labels array as categories
              title: {
                display: true,
                text: 'Year'
              },
              ticks: {
                callback: tickVal => `Year ${tickVal}`  // prepend Year ”
              }
            },
            y: {
              title: {
                display: true,
                text: 'Cumulative Return ($)'
              }
            }
          },
          plugins:{legend:{position:'top', labels: {usePointStyle: true,  pointStyle: 'circle', boxWidth: 8, boxHeight: 8, padding: 16}}},
        }
      });
    });

    // CSV export
    document.getElementById('downloadCsv').addEventListener('click',()=>{
      if(!dripData) return alert('Run calc first');
      const { labels, regReturnArr, dripReturnArr, totalNonDripReturnArr, totalDripReturnArr, contribThisMonthArr } = dripData;
      let csv = 'Month,Contribution,Regular Return,DRIP Return,Total non-DRIP Return,Total DRIP Return\n';
      labels.forEach((m,i)=>{
        csv += [
          m,
          contribThisMonthArr[i].toFixed(2),
          regReturnArr[i].toFixed(2),
          dripReturnArr[i].toFixed(2),
          totalNonDripReturnArr[i].toFixed(2),
          totalDripReturnArr[i].toFixed(2),
        ].join(',')+'\n';
      });
      const blob = new Blob([csv],{type:'text/csv'}), url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='drip_returns.csv'; a.click();
      URL.revokeObjectURL(url);
    });

    // Chart export
    document.getElementById('downloadChart').addEventListener('click', () => {
      if (!dripChart) return alert('Run calc first');
      const PAD   = 20;   // CSS-pixel padding around chart
      const SCALE = 2;    // 2× pixel density

      // 1) grab the on-screen chart <canvas> and its logical size
      const srcCanvas = dripChart.canvas;
      const cssW      = srcCanvas.width;
      const cssH      = srcCanvas.height;

      // 2) build an off-screen canvas
      const exportCanvas = document.createElement('canvas');
      // a) logical pixel size = (chart + 2*PAD) × SCALE
      exportCanvas.width  = (cssW + PAD * 2) * SCALE;
      exportCanvas.height = (cssH + PAD * 2) * SCALE;
      // b) keep its CSS size equal to the on-screen chart + padding
      exportCanvas.style.width  = `${cssW + PAD * 2}px`;
      exportCanvas.style.height = `${cssH + PAD * 2}px`;

      const ctx = exportCanvas.getContext('2d');
      // 3) scale drawing operations so that your chart is crisp
      ctx.scale(SCALE, SCALE);

      // 4) fill the entire off-screen canvas white (covers both chart area + padding)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, cssW + PAD * 2, cssH + PAD * 2);

      // 5) draw your on-screen chart into the middle
      //    note: drawImage uses the CSS-pixel dimensions here
      ctx.drawImage(srcCanvas, PAD, PAD, cssW, cssH);

      // 6) export that off-screen canvas
      exportCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a   = document.createElement('a');
        a.href    = url;
        a.download = 'drip_chart@2x.png';
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/png');
    })

    // Email data
    document.getElementById('emailData').addEventListener('click',()=>{
      if(!dripData) return alert('Run calc first');
      const { labels, regReturnArr, dripReturnArr, totalNonDripReturnArr, totalDripReturnArr, contribThisMonthArr } = dripData;
      let body = 'Month,Contribution,Regular Return,DRIP Return,Total non-DRIP Return,Total DRIP Return\n';
      labels.forEach((m,i)=>{
        body += [
          m,
          contribThisMonthArr[i].toFixed(2),
          regReturnArr[i].toFixed(2),
          dripReturnArr[i].toFixed(2),
          totalNonDripReturnArr[i].toFixed(2),
          totalDripReturnArr[i].toFixed(2),
        ].join(',')+'\n';
      });
      window.location.href = `mailto:?subject=${encodeURIComponent('DRIP Returns Data')}&body=${encodeURIComponent(body)}`;
    });

    // auto‐run
    document.addEventListener('DOMContentLoaded',()=>document.getElementById('calculateDrip').click());
  </script>
</body>
</html>
